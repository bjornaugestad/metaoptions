.Dd Nov 25, 2005
.Os ISO C99
.Dt META_OPTIONS 3
.Sh NAME
.Nm metaoptions
.Nd A collection of option formulas implemented in C
.Sh SYNOPSIS
#include <metaoptions.h>
.Fo "double AmericanExchangeOption"
.Fa "double S1"
.Fa "double S2"
.Fa "double Q1"
.Fa "double Q2"
.Fa "double T"
.Fa "double r"
.Fa "double b1"
.Fa "double b2"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double AssetOrNothing"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double AssetOrNothing_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double AssetOrNothing_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double BAWAmericanApprox"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double BAWbisection"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double price"
.Fc
.Fo "double BinaryBarrier"
.Fa "int TypeFlag"
.Fa "double S"
.Fa "double X"
.Fa "double H"
.Fa "double K"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "int eta"
.Fa "int phi"
.Fc
.Fo "double bisection"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double price"
.Fc
.Fo "double black76"
.Fa "int fCall"
.Fa "double F"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v"
.Fc
.Fo "static inline double black76_put"
.Fa "double F"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v"
.Fc
.Fo "static inline double black76_call"
.Fa "double F"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v"
.Fc
.Fo "double blackscholes"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v"
.Fc
.Fo "static inline double blackscholes_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v"
.Fc
.Fo "static inline double blackscholes_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v"
.Fc
.Fo "double BSAmericanCallApprox"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double BSbisection"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double price"
.Fc
.Fo "double CashOrNothing"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double K"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double CashOrNothing_inlined"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double K"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v" 
.Fc
.Fo "double cbnd"
.Fa "double a"
.Fa "double b"
.Fa "double rho"
.Fc
.Fo "double cnd"
.Fa "double x"
.Fc
.Fo "double ComplexChooser"
.Fa "double S"
.Fa "double Xc"
.Fa "double Xp"
.Fa "double T"
.Fa "double Tc" 
.Fa "double Tp"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double ConvertibleBond"
.Fa "int EuropeanOption"
.Fa "double S"
.Fa "double X"
.Fa "double T2"
.Fa "double t1"
.Fa "double r"
.Fa "double k"
.Fa "double q"
.Fa "double v"
.Fa "double F"
.Fa "double Coupon"
.Fa "int n"
.Fc
.Fo "double CRRBinomial"
.Fa "int EuropeanOption"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "int n"
.Fc
.Fo "double DiscreteAdjustedBarrier"
.Fa "double S"
.Fa "double H"
.Fa "double v"
.Fa "double dt"
.Fc
.Fo "double DoubleBarrier"
.Fa "int TypeFlag"
.Fa "double S"
.Fa "double X"
.Fa "double L"
.Fa "double U"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "double delta1"
.Fa "double delta2"
.Fc
.Fo "double EquityLinkedFXO"
.Fa "int fCall"
.Fa "double E"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double rf"
.Fa "double q"
.Fa "double vS"
.Fa "double vE"
.Fa "double rho"
.Fc
.Fo "double EuropeanExchangeOption"
.Fa "double S1"
.Fa "double S2"
.Fa "double Q1"
.Fa "double Q2"
.Fa "double T"
.Fa "double r"
.Fa "double b1"
.Fa "double b2"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double ExchangeExchangeOption"
.Fa "int TypeFlag"
.Fa "double S1"
.Fa "double S2"
.Fa "double q"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b1"
.Fa "double b2"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double Executive"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "double lambda"
.Fc
.Fo "static inline double Executive_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "double lambda" 
.Fc
.Fo "static inline double Executive_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "double lambda" 
.Fc
.Fo "double ExtendibleWriter"
.Fa "int fCall"
.Fa "double S"
.Fa "double X1"
.Fa "double X2"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double ExtremeSpreadOption"
.Fa "int TypeFlag"
.Fa "double S"
.Fa "double SMin"
.Fa "double SMax"
.Fa "double t1"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double FixedStrikeLookback"
.Fa "int fCall"
.Fa "double S"
.Fa "double SMin"
.Fa "double SMax"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double FloatingStrikeLookback"
.Fa "int fCall"
.Fa "double S"
.Fa "double SMin"
.Fa "double SMax"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double ForEquOptInDomCur"
.Fa "int fCall"
.Fa "double E"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double q"
.Fa "double vS"
.Fa "double vE"
.Fa "double rho"
.Fc
.Fo "double ForwardStartOption"
.Fa "int fCall"
.Fa "double S"
.Fa "double alpha"
.Fa "double t1"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double GapOption"
.Fa "int fCall"
.Fa "double S"
.Fa "double X1"
.Fa "double X2"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double gbs"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gbs_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gbs_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double gcarry"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gcarry_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gcarry_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double gdelta"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gdelta_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gdelta_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double GeometricAverageRateOption"
.Fa "int fCall"
.Fa "double S"
.Fa "double SA"
.Fa "double X"
.Fa "double T"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double gfrench"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double t1"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gfrench_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double t1"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gfrench_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double t1"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double ggamma"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double ggamma_inlined"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double grho"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double grho_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double grho_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double gtheta"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gtheta_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gtheta_put"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double gvega"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double gvega_inlined"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double ImpliedTrinomialTree"
.Fa "const char* ReturnFlag"
.Fa "int STEPn"
.Fa "int STATEi"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "double Skew"
.Fa "int nSteps"
.Fc
.Fo "double JumpDiffusion"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v"
.Fa "double lambda"
.Fa "double gamma"
.Fc
.Fo "double LevyAsian"
.Fa "int fCall"
.Fa "double S"
.Fa "double SA"
.Fa "double X"
.Fa "double T"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double merton73"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double q"
.Fa "double v"
.Fc
.Fo "double MiltersenSchwartz"
.Fa "int fCall"
.Fa "double Pt"
.Fa "double FT"
.Fa "double X"
.Fa "double t1"
.Fa "double T2"
.Fa "double vS"
.Fa "double vE"
.Fa "double vf"
.Fa "double rhoSe"
.Fa "double rhoSf"
.Fa "double rhoef"
.Fa "double Kappae"
.Fa "double Kappaf"
.Fc
.Fo "double NewtonRaphson"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double cm"
.Fc
.Fo "double NewtonRaphson_put "
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double cm"
.Fc
.Fo "double NewtonRaphson_call"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double cm"
.Fc
.Fo "static inline double normdist"
.Fa "double x"
.Fc
.Fo "double OptionsOnOptions"
.Fa "int typeflag"
.Fa "double S"
.Fa "double X1"
.Fa "double X2"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double OptionsOnTheMaxMin"
.Fa "const char* TypeFlag"
.Fa "double S1"
.Fa "double S2"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b1"
.Fa "double b2"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double PartialFixedLB"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double PartialFloatLB"
.Fa "int fCall"
.Fa "double S"
.Fa "double SMin"
.Fa "double SMax"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "double lambda"
.Fc
.Fo "double PartialTimeBarrier"
.Fa "const char* TypeFlag"
.Fa "double S"
.Fa "double X"
.Fa "double H"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double pow2"
.Fa "double n"
.Fc
.Fo "double Quanto"
.Fa "int fCall"
.Fa "double Ep"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double rf"
.Fa "double q"
.Fa "double vS"
.Fa "double vE"
.Fa "double rho"
.Fc
.Fo "double RollGeskeWhaley"
.Fa "double S"
.Fa "double X"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double d"
.Fa "double v"
.Fc
.Fo "static inline double sign"
.Fa "double d"
.Fc
.Fo "double SimpleChooser"
.Fa "double S"
.Fa "double X"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double SpreadApproximation"
.Fa "int fCall"
.Fa "double f1"
.Fa "double f2"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double StandardBarrier"
.Fa "int typeflag"
.Fa "double S"
.Fa "double X"
.Fa "double H"
.Fa "double K"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double SoftBarrier"
.Fa "int typeflag"
.Fa "double S"
.Fa "double X"
.Fa "double L"
.Fa "double U"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double PartialTimeTwoAssetBarrier"
.Fa "int typeflag"
.Fa "double S1"
.Fa "double S2"
.Fa "double X"
.Fa "double H"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b1"
.Fa "double b2"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double LookBarrier"
.Fa "int type"
.Fa "double S"
.Fa "double X"
.Fa "double H"
.Fa "double t1"
.Fa "double T2"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double BarrierBinomial"
.Fa "int EuropeanOption"
.Fa "int type"
.Fa "double S"
.Fa "double X"
.Fa "double H"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "int n"
.Fc
.Fo "double SuperShare"
.Fa "double S"
.Fa "double XL"
.Fa "double XH"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "static inline double SuperShare_inlined"
.Fa "double S"
.Fa "double XL"
.Fa "double XH"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v" 
.Fc
.Fo "double Swapoption"
.Fa "int fCall"
.Fa "double t1"
.Fa "double m"
.Fa "double F"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double v"
.Fc
.Fo "double TakeoverFXoption"
.Fa "double v"
.Fa "double b"
.Fa "double E"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double rf"
.Fa "double vV"
.Fa "double vE"
.Fa "double rho"
.Fc
.Fo "double ThreeDimensionalBinomial"
.Fa "int type"
.Fa "int EuropeanOption"
.Fa "int fCall"
.Fa "double S1"
.Fa "double S2"
.Fa "double Q1"
.Fa "double Q2"
.Fa "double X1"
.Fa "double X2"
.Fa "double T"
.Fa "double r"
.Fa "double b1"
.Fa "double b2"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fa "int n"
.Fc
.Fo "double TimeSwitchOption"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double a"
.Fa "double T"
.Fa "int m"
.Fa "double dt"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double TrinomialTree"
.Fa "int EuropeanOption"
.Fa "int fCall"
.Fa "double S"
.Fa "double X"
.Fa "double T"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fa "double n"
.Fc
.Fo "double TurnbullWakemanAsian"
.Fa "int fCall"
.Fa "double S"
.Fa "double SA"
.Fa "double X"
.Fa "double T"
.Fa "double T2"
.Fa "double tau"
.Fa "double r"
.Fa "double b"
.Fa "double v"
.Fc
.Fo "double TwoAssetBarrier"
.Fa "int type"
.Fa "double S1"
.Fa "double S2"
.Fa "double X"
.Fa "double H"
.Fa "double T"
.Fa "double r"
.Fa "double b1"
.Fa "double b2"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double TwoAssetCashOrNothing"
.Fa "int TypeFlag"
.Fa "double S1"
.Fa "double S2"
.Fa "double X1"
.Fa "double X2"
.Fa "double K"
.Fa "double T"
.Fa "double r" 
.Fa "double b1"
.Fa "double b2"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double TwoAssetCorrelation"
.Fa "int fCall"
.Fa "double S1"
.Fa "double S2"
.Fa "double X1"
.Fa "double X2"
.Fa "double T"
.Fa "double b1"
.Fa "double b2"
.Fa "double r"
.Fa "double v1"
.Fa "double v2"
.Fa "double rho"
.Fc
.Fo "double VasicekBondOption"
.Fa "int fCall"
.Fa "double F"
.Fa "double X"
.Fa "double tau"
.Fa "double T"
.Fa "double r"
.Fa "double theta"
.Fa "double kappa"
.Fa "double v"
.Fc
.Fo "double VasicekBondPrice"
.Fa "double t1"
.Fa "double T"
.Fa "double r"
.Fa "double theta"
.Fa "double kappa"
.Fa "double v"
.Fc
.Sh DESCRIPTION
.Ss Constants
Some constants we use a lot.
The M_E and friends from math.h is not a part of the ANSI C standard,
so we add them here instead.
e, pi and sqrt(2*pi);
A common calculation is (1/sqrt2pi) *e, which equals e/sqr2pi.
.Bd -literal
static const double e = 2.7182818284590452354;
static const double pi = 3.14159265358979323846;    
static const double sqrt2pi = 2.50662827463100024161;
static const double e_div_sqrt2pi = 1.08443755141922748564;
static const double one_div_sqrt2pi = 0.39894228040143270286;
.Be
.Ss Error checking macros
.Bd -literal
#define assert_valid_strike(X)          assert(isfinite(X) && X > 0.0)
#define assert_valid_price(S)           assert(isfinite(S) && S > 0.0)
#define assert_valid_time(T)            assert(isfinite(T) && T > 0.0) 
#define assert_valid_cost_of_carry(b)   assert(isfinite(b) && b >= 0.0)
#define assert_valid_volatility(v)      assert(isfinite(v) && v > 0.0 && v <= 100.0);
.Be

.Ss parameter rules
X - Strike
S - Stock price right now
T - Time to expiry as fraction of year. 6 months == 0.5, 9 months == 0.75
r - Risk free interest rate. 10% == 0.10
b - Cost of Carry. 10% == 0.10
v - Volatility, 30% == 0.30

